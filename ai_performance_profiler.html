        /**
         * Calculate thermal throttling factor based on elapsed time
         * @param {number} elapsedTime - Elapsed time in seconds
         * @returns {number} Throttling factor (0.0 to 1.0)
         */
        function getThermalThrottling(elapsedTime) {
            // Simulate thermal buildup over time
            const maxThrottling = 0.15; // Maximum 15% throttling
            const throttlingStart = 300; // Start throttling after 5 minutes
            
            if (elapsedTime < throttlingStart) return 1.0;
            
            const throttlingFactor = Math.min(maxThrottling, (elapsedTime - throttlingStart) / 1800);
            return 1.0 - throttlingFactor;
        }

        /**
         * Calculate batch size efficiency
         * @param {number} batchSize - Current batch size
         * @returns {number} Efficiency factor (0.0 to 1.0)
         */
        function getBatchEfficiency(batchSize) {
            // Optimal batch size efficiency curve
            const optimalBatch = 64;
            const efficiency = Math.exp(-Math.pow((batchSize - optimalBatch) / 40, 2));
            return Math.max(0.6, efficiency);
        }

        /**
         * Calculate GPU temperature based on power draw and time
         * @param {number} powerDraw - Current power draw in watts
         * @param {number} elapsedTime - Elapsed time in seconds
         * @returns {number} Temperature in Celsius
         */
        function calculateTemperature(powerDraw, elapsedTime) {
            const ambientTemp = 22; // Room temperature
            const maxTemp = AppState.config.hardware === 'h100' ? 75 : 83;
            const heatupRate = powerDraw / 1000; // Temperature rise rate
            
            const targetTemp = ambientTemp + (maxTemp - ambientTemp) * (powerDraw / 700);
            const currentTemp = ambientTemp + (targetTemp - ambientTemp) * (1 - Math.exp(-elapsedTime / 300));
            
            return Math.min(maxTemp, currentTemp);
        }

        /**
         * Calculate training loss curve (realistic decay)
         * @param {number} elapsedTime - Elapsed time in seconds
         * @returns {number} Training loss value
         */
        function calculateTrainingLoss(elapsedTime) {
            const initialLoss = 8.5;
            const finalLoss = 2.1;
            const decayRate = 0.001;
            
            const progress = 1 - Math.exp(-decayRate * elapsedTime);
            const baseLoss = initialLoss - (initialLoss - finalLoss) * progress;
            
            // Add realistic noise
            const noise = (Math.random() - 0.5) * 0.3;
            return Math.max(0.1, baseLoss + noise);
        }

        /**
         * Calculate validation loss (follows training with some lag and noise)
         * @param {number} elapsedTime - Elapsed time in seconds
         * @param {number} trainingLoss - Current training loss
         * @returns {number} Validation loss value
         */
        function calculateValidationLoss(elapsedTime, trainingLoss) {
            // Validation loss typically higher than training loss
            const validationOffset = 0.4;
            const noise = (Math.random() - 0.5) * 0.2;
            
            return Math.max(0.1, trainingLoss + validationOffset + noise);
        }

        /**
         * Calculate learning rate schedule
         * @param {number} elapsedTime - Elapsed time in seconds
         * @returns {number} Current learning rate
         */
        function calculateLearningRate(elapsedTime) {
            const initialLR = 1e-4;
            const decaySteps = 1800; // 30 minutes
            const decayRate = 0.95;
            
            const step = Math.floor(elapsedTime / decaySteps);
            return initialLR * Math.pow(decayRate, step);
        }

        /**
         * Get default metrics in case of calculation errors
         * @returns {Object} Default metrics object
         */
        function getDefaultMetrics() {
            return {
                throughput: 0,
                latency: 0,
                gpuUtilization: 0,
                memoryUsage: 0,
                powerDraw: 0,
                temperature: 22,
                efficiency: 0,
                flops: 0,
                costPerHour: 0,
                trainingLoss: null,
                validationLoss: null,
                learningRate: null
            };
        }

        // ============================================================================
        // UI UPDATE FUNCTIONS
        // ============================================================================

        /**
         * Update metric displays in the UI
         * @param {Object} metrics - Performance metrics object
         */
        function updateMetricDisplays(metrics) {
            try {
                // Update main metric cards
                updateElementText('gpuUtil', metrics.gpuUtilization);
                updateElementText('memoryUsage', metrics.memoryUsage);
                updateElementText('throughput', metrics.throughput);
                updateElementText('powerDraw', metrics.powerDraw);
                
                // Update performance grid
                updateElementText('gpuTemp', metrics.temperature);
                updateElementText('efficiency', metrics.efficiency);
                updateElementText('flops', metrics.flops);
                updateElementText('costPerHour', metrics.costPerHour);

            } catch (error) {
                console.error('❌ Error updating metric displays:', error);
            }
        }

        /**
         * Update charts with new data points
         * @param {Object} metrics - Performance metrics object
         * @param {number} elapsedTime - Elapsed time in seconds
         */
        function updateCharts(metrics, elapsedTime) {
            try {
                const timeLabel = formatTime(elapsedTime);
                const maxDataPoints = 50; // Limit data points for performance

                // Update performance chart
                if (AppState.charts.performance) {
                    const perfChart = AppState.charts.performance;
                    perfChart.data.labels.push(timeLabel);
                    perfChart.data.datasets[0].data.push(metrics.throughput);
                    perfChart.data.datasets[1].data.push(metrics.latency);
                    
                    // Trim data if too many points
                    if (perfChart.data.labels.length > maxDataPoints) {
                        perfChart.data.labels.shift();
                        perfChart.data.datasets[0].data.shift();
                        perfChart.data.datasets[1].data.shift();
                    }
                    
                    perfChart.update('none'); // No animation for performance
                }

                // Update resource utilization chart
                if (AppState.charts.resource) {
                    const resourceChart = AppState.charts.resource;
                    const memoryPercent = (metrics.memoryUsage / AppState.config.memoryLimit) * 100;
                    const available = 100 - metrics.gpuUtilization - memoryPercent - 10; // 10% for system
                    
                    resourceChart.data.datasets[0].data = [
                        memoryPercent,
                        10, // System memory (simplified)
                        metrics.gpuUtilization,
                        Math.max(0, available)
                    ];
                    
                    resourceChart.update('none');
                }

                // Update training chart (if in training mode)
                if (AppState.charts.training && AppState.currentMode === 'training' && metrics.trainingLoss !== null) {
                    const trainingChart = AppState.charts.training;
                    trainingChart.data.labels.push(timeLabel);
                    trainingChart.data.datasets[0].data.push(metrics.trainingLoss);
                    trainingChart.data.datasets[1].data.push(metrics.validationLoss);
                    trainingChart.data.datasets[2].data.push(metrics.learningRate);
                    
                    // Trim data if too many points
                    if (trainingChart.data.labels.length > maxDataPoints) {
                        trainingChart.data.labels.shift();
                        trainingChart.data.datasets[0].data.shift();
                        trainingChart.data.datasets[1].data.shift();
                        trainingChart.data.datasets[2].data.shift();
                    }
                    
                    trainingChart.update('none');
                }

                // Update health chart
                if (AppState.charts.health) {
                    const healthChart = AppState.charts.health;
                    const maxTemp = HardwareSpecs[AppState.config.hardware].thermalLimit;
                    const tempPercent = (metrics.temperature / maxTemp) * 100;
                    const powerPercent = (metrics.powerDraw / (HardwareSpecs[AppState.config.hardware].powerDraw * AppState.config.numGpus)) * 100;
                    
                    healthChart.data.datasets[0].data = [
                        tempPercent,
                        powerPercent,
                        tempPercent - 5, // Memory temp slightly lower
                        Math.min(100, powerPercent + 10) // Fan speed correlates with power
                    ];
                    
                    healthChart.update('none');
                }

            } catch (error) {
                console.error('❌ Error updating charts:', error);
            }
        }

        /**
         * Helper function to safely update element text content
         * @param {string} elementId - Element ID
         * @param {*} value - Value to set
         */
        function updateElementText(elementId, value) {
            try {
                const element = document.getElementById(elementId);
                if (element && value !== null && value !== undefined) {
                    element.textContent = value;
                }
            } catch (error) {
                console.error(`❌ Error updating element ${elementId}:`, error);
            }
        }

        /**
         * Format elapsed time for chart labels
         * @param {number} seconds - Time in seconds
         * @returns {string} Formatted time string
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // ============================================================================
        // CONFIGURATION MANAGEMENT
        // ============================================================================

        /**
         * Update configuration based on current UI state
         */
        function updateConfiguration() {
            try {
                // This function is called whenever UI controls change
                // The actual config updates happen in the event listeners
                console.log('📋 Configuration updated:', AppState.config);
                
            } catch (error) {
                console.error('❌ Error updating configuration:', error);
            }
        }

        /**
         * Update model size options when model type changes
         */
        function updateModelSizeOptions() {
            try {
                const modelSizeSlider = document.getElementById('modelSize');
                const modelSizeValue = document.getElementById('modelSizeValue');
                
                if (modelSizeSlider && modelSizeValue) {
                    const config = ModelConfigs[AppState.config.modelType];
                    modelSizeSlider.max = config.sizes.length - 1;
                    
                    // Reset to middle value
                    const middleIndex = Math.floor(config.sizes.length / 2);
                    modelSizeSlider.value = middleIndex;
                    AppState.config.modelSize = config.sizes[middleIndex];
                    modelSizeValue.textContent = config.labels[middleIndex];
                }

            } catch (error) {
                console.error('❌ Error updating model size options:', error);
            }
        }

        /**
         * Update memory limit range based on selected hardware
         */
        function updateMemoryLimitRange() {
            try {
                const memoryLimitSlider = document.getElementById('memoryLimit');
                const memoryLimitValue = document.getElementById('memoryLimitValue');
                
                if (memoryLimitSlider && memoryLimitValue) {
                    const hardwareSpec = HardwareSpecs[AppState.config.hardware];
                    const maxMemory = hardwareSpec.memory * AppState.config.numGpus;
                    
                    memoryLimitSlider.max = maxMemory;
                    memoryLimitSlider.value = Math.min(AppState.config.memoryLimit, maxMemory);
                    AppState.config.memoryLimit = parseInt(memoryLimitSlider.value);
                    memoryLimitValue.textContent = AppState.config.memoryLimit;
                }

            } catch (error) {
                console.error('❌ Error updating memory limit range:', error);
            }
        }

        /**
         * Validate current configuration for feasibility
         * @returns {boolean} True if configuration is valid
         */
        function validateConfiguration() {
            try {
                const config = AppState.config;
                const modelConfig = ModelConfigs[config.modelType];
                const hardwareSpec = HardwareSpecs[config.hardware];
                const precisionConfig = PrecisionConfigs[config.precision];

                // Calculate memory requirements
                const parametersInBillions = config.modelSize / 1e9;
                const memoryRequired = parametersInBillions * modelConfig.memoryMultiplier * precisionConfig.memoryFactor;
                const totalMemory = hardwareSpec.memory * config.numGpus;

                // Check if model fits in memory
                if (memoryRequired > totalMemory) {
                    showError(`Model requires ${memoryRequired.toFixed(1)}GB but only ${totalMemory}GB available. Try reducing model size or changing precision.`);
                    return false;
                }

                // Check if batch size is reasonable
                if (config.batchSize > 256) {
                    console.warn('⚠️ Very large batch size may cause memory issues');
                }

                return true;

            } catch (error) {
                console.error('❌ Error validating configuration:', error);
                return false;
            }
        }

        // ============================================================================
        // SIMULATION LOOP AND TIMING
        // ============================================================================

        /**
         * Start the main simulation loop
         */
        function startSimulationLoop() {
            try {
                function loop() {
                    simulationStep();
                    AppState.animationId = requestAnimationFrame(loop);
                }
                
                loop();
                console.log('🔄 Simulation loop started');

            } catch (error) {
                console.error('❌ Failed to start simulation loop:', error);
            }
        }

        /**
         * Clear all simulation data
         */
        function clearSimulationData() {
            try {
                // Clear chart data
                Object.values(AppState.charts).forEach(chart => {
                    if (chart && chart.data) {
                        chart.data.labels = [];
                        chart.data.datasets.forEach(dataset => {
                            dataset.data = [];
                        });
                        chart.update();
                    }
                });

                // Reset simulation data arrays
                AppState.simulationData = {
                    performance: [],
                    resources: [],
                    training: [],
                    health: []
                };

            } catch (error) {
                console.error('❌ Error clearing simulation data:', error);
            }
        }

        // ============================================================================
        // UTILITY FUNCTIONS AND ERROR HANDLING
        // ============================================================================

        /**
         * Show loading spinner
         * @param {boolean} show - Whether to show or hide loading
         */
        function showLoading(show) {
            try {
                const spinner = document.getElementById('loadingSpinner');
                if (spinner) {
                    spinner.style.display = show ? 'block' : 'none';
                }
            } catch (error) {
                console.error('❌ Error toggling loading spinner:', error);
            }
        }

        /**
         * Show error message to user
         * @param {string} message - Error message to display
         */
        function showError(message) {
            try {
                const errorElement = document.getElementById('errorMessage');
                if (errorElement) {
                    errorElement.textContent = message;
                    errorElement.style.display = 'block';
                    
                    // Auto-hide error after 5 seconds
                    setTimeout(() => {
                        hideError();
                    }, 5000);
                }
            } catch (error) {
                console.error('❌ Error showing error message:', error);
            }
        }

        /**
         * Hide error message
         */
        function hideError() {
            try {
                const errorElement = document.getElementById('errorMessage');
                if (errorElement) {
                    errorElement.style.display = 'none';
                }
            } catch (error) {
                console.error('❌ Error hiding error message:', error);
            }
        }

        /**
         * Handle window resize events
         */
        function handleWindowResize() {
            try {
                // Resize all charts
                Object.values(AppState.charts).forEach(chart => {
                    if (chart && typeof chart.resize === 'function') {
                        chart.resize();
                    }
                });
            } catch (error) {
                console.error('❌ Error handling window resize:', error);
            }
        }

        /**
         * Handle page visibility changes for performance optimization
         */
        function handleVisibilityChange() {
            try {
                if (document.hidden) {
                    // Page is hidden, we could pause expensive operations
                    console.log('🔇 Application paused (tab hidden)');
                } else {
                    // Page is visible again
                    console.log('🔊 Application resumed (tab visible)');
                }
            } catch (error) {
                console.error('❌ Error handling visibility change:', error);
            }
        }

        /**
         * Cleanup function to prevent memory leaks
         */
        function cleanup() {
            try {
                // Stop simulation
                stopSimulation();
                
                // Cancel animation frame
                if (AppState.animationId) {
                    cancelAnimationFrame(AppState.animationId);
                    AppState.animationId = null;
                }
                
                // Destroy all charts
                Object.values(AppState.charts).forEach(chart => {
                    if (chart && typeof chart.destroy === 'function') {
                        chart.destroy();
                    }
                });
                
                AppState.charts = {};
                
                console.log('🧹 Cleanup completed');

            } catch (error) {
                console.error('❌ Error during cleanup:', error);
            }
        }

        // ============================================================================
        // APPLICATION INITIALIZATION
        // ============================================================================

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            try {
                initializeApplication();
            } catch (error) {
                console.error('❌ Critical error during initialization:', error);
                showError('Critical error during initialization. Please refresh the page.');
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            try {
                cleanup();
            } catch (error) {
                console.error('❌ Error during page unload cleanup:', error);
            }
        });

        // Handle page hide event for better mobile support
        window.addEventListener('pagehide', () => {
            try {
                cleanup();
            } catch (error) {
                console.error('❌ Error during page hide cleanup:', error);
            }
        });

        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('💥 Unhandled error:', event.error);
            
            // Show user-friendly error for critical failures
            if (event.error && event.error.message && 
                (event.error.message.includes('Chart') || 
                 event.error.message.includes('canvas') ||
                 event.error.message.includes('WebGL'))) {
                showError('A graphics error occurred. Please refresh the page.');
            }
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            console.error('💥 Unhandled promise rejection:', event.reason);
            event.preventDefault();
        });

        // Performance monitoring (optional)
        if ('performance' in window) {
            window.addEventListener('load', () => {
                setTimeout(() => {
                    const perfData = performance.getEntriesByType('navigation')[0];
                    console.log(`⚡ Application loaded in ${Math.round(perfData.loadEventEnd - perfData.fetchStart)}ms`);
                }, 0);
            });
        }

        // Export for potential external use (if needed)
        window.AIPerformanceProfiler = {
            start: (mode) => startSimulation(mode),
            stop: () => stopSimulation(),
            getState: () => ({ ...AppState }),
            cleanup: cleanup
        };

        console.log('🎯 AI Performance Profiler script loaded successfully');
    </script>
</body>
</html>        /**
         * Initialize all Chart.js instances with proper configurations
         */
        function initializeCharts() {
            try {
                // Common chart options for consistent styling
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#ffffff',
                                font: { size: 12 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { color: '#a0a0a0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    animation: {
                        duration: 300 // Smooth but fast updates
                    }
                };

                // Performance Metrics Chart (Line chart)
                const performanceCtx = document.getElementById('performanceChart');
                if (performanceCtx) {
                    AppState.charts.performance = new Chart(performanceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Throughput (tokens/s)',
                                    data: [],
                                    borderColor: '#00f5ff',
                                    backgroundColor: 'rgba(0, 245, 255, 0.1)',
                                    tension: 0.4,
                                    fill: true
                                },
                                {
                                    label: 'Latency (ms)',
                                    data: [],
                                    borderColor: '#ff0080',
                                    backgroundColor: 'rgba(255, 0, 128, 0.1)',
                                    tension: 0.4,
                                    fill: true,
                                    yAxisID: 'y1'
                                }
                            ]
                        },
                        options: {
                            ...commonOptions,
                            scales: {
                                ...commonOptions.scales,
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    ticks: { color: '#a0a0a0' },
                                    grid: { drawOnChartArea: false }
                                }
                            }
                        }
                    });
                }

                // Resource Utilization Chart (Doughnut chart)
                const resourceCtx = document.getElementById('resourceChart');
                if (resourceCtx) {
                    AppState.charts.resource = new Chart(resourceCtx, {
                <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Model Performance Profiler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 25%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00f5ff, #ff0080, #8000ff, #00ff80);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease-in-out infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .subtitle {
            color: #a0a0a0;
            font-size: 1.1em;
            font-weight: 300;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 25px;
            height: fit-content;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }
        
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #00f5ff, #ff0080);
            border-radius: 3px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 20px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            position: relative;
        }
        
        .chart-container h3 {
            color: #00f5ff;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chart-container canvas {
            max-height: 300px !important;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group h3 {
            color: #ff0080;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #c0c0c0;
            font-size: 0.9em;
            font-weight: 500;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }
        
        input[type="range"] {
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #ff0080, #00f5ff, #8000ff);
            border-radius: 4px;
            padding: 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ffffff, #00f5ff);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #00f5ff;
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
        }
        
        .metric-title {
            font-size: 0.85em;
            color: #a0a0a0;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #00f5ff;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        .status-training {
            background: #ff0080;
        }
        
        .status-inference {
            background: #00f5ff;
        }
        
        .status-idle {
            background: #666;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.95); }
        }
        
        .action-button {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(45deg, #ff0080, #00f5ff);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .action-button:hover::before {
            left: 100%;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 0, 128, 0.4);
        }
        
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255, 0, 128, 0.2);
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .perf-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .perf-label {
            font-size: 0.8em;
            color: #a0a0a0;
            margin-bottom: 5px;
        }
        
        .perf-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #8000ff;
        }
        
        .loading-spinner {
            display: none;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #00f5ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.4);
            color: #ffaaaa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .control-panel, .chart-container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <div class="header">
            <h1>AI Performance Profiler</h1>
            <p class="subtitle">Real-time monitoring and analysis of AI model performance characteristics</p>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-group">
                <h3>🤖 Model Configuration</h3>
                
                <div class="control-item">
                    <label for="modelType">Model Architecture</label>
                    <select id="modelType">
                        <option value="transformer">Transformer (GPT-style)</option>
                        <option value="cnn">Convolutional Neural Network</option>
                        <option value="rnn">Recurrent Neural Network</option>
                        <option value="diffusion">Diffusion Model</option>
                        <option value="vit">Vision Transformer</option>
                        <option value="custom">Custom Architecture</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <label for="modelSize">Model Size: <span id="modelSizeValue">7B</span> Parameters</label>
                    <input type="range" id="modelSize" min="0" max="8" value="4" step="1">
                </div>
                
                <div class="control-item">
                    <label for="batchSize">Batch Size: <span id="batchSizeValue">32</span></label>
                    <input type="range" id="batchSize" min="1" max="128" value="32">
                </div>
                
                <div class="control-item">
                    <label for="precision">Precision</label>
                    <select id="precision">
                        <option value="fp32">FP32 (32-bit)</option>
                        <option value="fp16" selected>FP16 (16-bit)</option>
                        <option value="int8">INT8 (8-bit)</option>
                        <option value="int4">INT4 (4-bit)</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <h3>⚡ Hardware Settings</h3>
                
                <div class="control-item">
                    <label for="hardware">Hardware Type</label>
                    <select id="hardware">
                        <option value="rtx4090">RTX 4090</option>
                        <option value="a100" selected>A100 (40GB)</option>
                        <option value="h100">H100 (80GB)</option>
                        <option value="tpu-v4">TPU v4</option>
                        <option value="cpu">CPU Only</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <label for="numGpus">Number of GPUs: <span id="numGpusValue">1</span></label>
                    <input type="range" id="numGpus" min="1" max="8" value="1">
                </div>
                
                <div class="control-item">
                    <label for="memoryLimit">Memory Limit: <span id="memoryLimitValue">40</span> GB</label>
                    <input type="range" id="memoryLimit" min="8" max="80" value="40">
                </div>
            </div>
            
            <div class="control-group">
                <h3>📊 Simulation Controls</h3>
                
                <button class="action-button" id="startTraining">
                    <span class="status-indicator status-training"></span>
                    Start Training
                </button>
                
                <button class="action-button" id="startInference">
                    <span class="status-indicator status-inference"></span>
                    Run Inference
                </button>
                
                <button class="action-button" id="stopSimulation">
                    <span class="status-indicator status-idle"></span>
                    Stop Simulation
                </button>
                
                <div class="loading-spinner" id="loadingSpinner"></div>
                <div class="error-message" id="errorMessage"></div>
            </div>
            
            <div class="control-group">
                <h3>📈 Current Metrics</h3>
                
                <div class="metric-card">
                    <div class="metric-title">GPU Utilization</div>
                    <div class="metric-value"><span id="gpuUtil">0</span>%</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">Memory Usage</div>
                    <div class="metric-value"><span id="memoryUsage">0.0</span> GB</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">Throughput</div>
                    <div class="metric-value"><span id="throughput">0</span> tok/s</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-title">Power Draw</div>
                    <div class="metric-value"><span id="powerDraw">0</span>W</div>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Performance Chart -->
            <div class="chart-container">
                <h3>🚀 Performance Metrics</h3>
                <canvas id="performanceChart"></canvas>
            </div>
            
            <!-- Resource Utilization -->
            <div class="chart-container">
                <h3>💾 Resource Utilization</h3>
                <canvas id="resourceChart"></canvas>
            </div>
            
            <!-- Training Progress -->
            <div class="chart-container">
                <h3>📚 Training Progress</h3>
                <canvas id="trainingChart"></canvas>
            </div>
            
            <!-- System Health -->
            <div class="chart-container">
                <h3>🌡️ System Health</h3>
                <canvas id="healthChart"></canvas>
                
                <div class="performance-grid">
                    <div class="perf-item">
                        <div class="perf-label">GPU Temp</div>
                        <div class="perf-value"><span id="gpuTemp">42</span>°C</div>
                    </div>
                    <div class="perf-item">
                        <div class="perf-label">Efficiency</div>
                        <div class="perf-value"><span id="efficiency">87</span>%</div>
                    </div>
                    <div class="perf-item">
                        <div class="perf-label">FLOPS</div>
                        <div class="perf-value"><span id="flops">156</span>T</div>
                    </div>
                    <div class="perf-item">
                        <div class="perf-label">Cost/Hour</div>
                        <div class="perf-value">$<span id="costPerHour">2.40</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * AI Model Performance Profiler
         * 
         * A sophisticated real-time performance monitoring system for AI models
         * Simulates and visualizes training/inference performance across different
         * hardware configurations and model architectures.
         * 
         * Features:
         * - Real-time performance metrics simulation
         * - Multiple model architecture support
         * - Hardware configuration profiling
         * - Interactive charts and visualizations
         * - Resource utilization monitoring
         * 
         * @author GitHub Portfolio Project
         * @version 1.0.0
         */

        // ============================================================================
        // GLOBAL STATE AND CONFIGURATION
        // ============================================================================

        /**
         * Application state management
         */
        const AppState = {
            isRunning: false,           // Simulation running state
            currentMode: 'idle',        // Current operation mode (training/inference/idle)
            startTime: null,            // Simulation start timestamp
            animationId: null,          // Animation frame ID for cleanup
            charts: {},                 // Chart.js instances storage
            simulationData: {           // Current simulation metrics
                performance: [],
                resources: [],
                training: [],
                health: []
            },
            config: {                   // Current configuration
                modelType: 'transformer',
                modelSize: 7000000000,  // 7B parameters
                batchSize: 32,
                precision: 'fp16',
                hardware: 'a100',
                numGpus: 1,
                memoryLimit: 40
            }
        };

        /**
         * Model architecture configurations with realistic parameter counts and characteristics
         */
        const ModelConfigs = {
            transformer: {
                sizes: [125000000, 350000000, 760000000, 1500000000, 7000000000, 13000000000, 30000000000, 65000000000, 175000000000],
                labels: ['125M', '350M', '760M', '1.5B', '7B', '13B', '30B', '65B', '175B'],
                memoryMultiplier: 2.5,   // Memory overhead factor
                computeIntensity: 1.0,   // Relative compute requirement
                parallelEfficiency: 0.85 // Parallel scaling efficiency
            },
            cnn: {
                sizes: [25000000, 60000000, 140000000, 500000000, 1000000000, 2000000000, 5000000000, 10000000000, 25000000000],
                labels: ['25M', '60M', '140M', '500M', '1B', '2B', '5B', '10B', '25B'],
                memoryMultiplier: 1.8,
                computeIntensity: 0.7,
                parallelEfficiency: 0.95
            },
            rnn: {
                sizes: [50000000, 100000000, 300000000, 800000000, 1500000000, 3000000000, 6000000000, 12000000000, 25000000000],
                labels: ['50M', '100M', '300M', '800M', '1.5B', '3B', '6B', '12B', '25B'],
                memoryMultiplier: 3.0,
                computeIntensity: 0.6,
                parallelEfficiency: 0.6
            },
            diffusion: {
                sizes: [100000000, 300000000, 800000000, 1500000000, 3000000000, 6000000000, 12000000000, 25000000000, 50000000000],
                labels: ['100M', '300M', '800M', '1.5B', '3B', '6B', '12B', '25B', '50B'],
                memoryMultiplier: 2.2,
                computeIntensity: 1.3,
                parallelEfficiency: 0.9
            },
            vit: {
                sizes: [86000000, 300000000, 630000000, 1300000000, 2500000000, 5000000000, 10000000000, 22000000000, 50000000000],
                labels: ['86M', '300M', '630M', '1.3B', '2.5B', '5B', '10B', '22B', '50B'],
                memoryMultiplier: 2.0,
                computeIntensity: 0.9,
                parallelEfficiency: 0.92
            },
            custom: {
                sizes: [1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 500000000000, 1000000000000, 10000000000000],
                labels: ['1M', '10M', '100M', '1B', '10B', '100B', '500B', '1T', '10T'],
                memoryMultiplier: 2.0,
                computeIntensity: 1.0,
                parallelEfficiency: 0.8
            }
        };

        /**
         * Hardware specifications with realistic performance characteristics
         */
        const HardwareSpecs = {
            'rtx4090': {
                memory: 24,              // GB
                peakTflops: 165,         // TensorFlow operations per second
                powerDraw: 450,          // Watts
                costPerHour: 0.90,       // USD
                efficiency: 0.85,        // Utilization efficiency
                thermalLimit: 83         // °C
            },
            'a100': {
                memory: 40,
                peakTflops: 312,
                powerDraw: 400,
                costPerHour: 2.40,
                efficiency: 0.92,
                thermalLimit: 78
            },
            'h100': {
                memory: 80,
                peakTflops: 989,
                powerDraw: 700,
                costPerHour: 4.80,
                efficiency: 0.95,
                thermalLimit: 75
            },
            'tpu-v4': {
                memory: 32,
                peakTflops: 275,
                powerDraw: 200,
                costPerHour: 1.60,
                efficiency: 0.98,
                thermalLimit: 65
            },
            'cpu': {
                memory: 128,
                peakTflops: 5,
                powerDraw: 200,
                costPerHour: 0.50,
                efficiency: 0.60,
                thermalLimit: 70
            }
        };

        /**
         * Precision configurations affecting memory and performance
         */
        const PrecisionConfigs = {
            'fp32': { memoryFactor: 1.0, speedFactor: 1.0, accuracyFactor: 1.0 },
            'fp16': { memoryFactor: 0.5, speedFactor: 1.8, accuracyFactor: 0.99 },
            'int8': { memoryFactor: 0.25, speedFactor: 3.2, accuracyFactor: 0.95 },
            'int4': { memoryFactor: 0.125, speedFactor: 5.5, accuracyFactor: 0.88 }
        };

        // ============================================================================
        // INITIALIZATION AND SETUP
        // ============================================================================

        /**
         * Initialize the entire application
         * Sets up charts, event listeners, and initial state
         */
        function initializeApplication() {
            try {
                console.log('🚀 Initializing AI Performance Profiler...');
                
                // Initialize all chart components
                initializeCharts();
                
                // Setup user interface controls
                setupEventListeners();
                
                // Load initial configuration
                updateConfiguration();
                
                // Start the main simulation loop
                startSimulationLoop();
                
                console.log('✅ Application initialized successfully');
                
            } catch (error) {
                console.error('❌ Failed to initialize application:', error);
                showError('Failed to initialize the performance profiler. Please refresh the page.');
            }
        }